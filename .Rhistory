# subtract dependent and independent variables for each regression
coef <- vector("list", length = node)
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
i
x_index
temp_n_levels
get_coef_matrix <- function(coef_vec, n_levels, x_index) {
node <- 1:length(x_index)
node_index <- rep(node, (n_levels-1))
if (!is.matrix(coef_vec)) {coef_vec <- matrix(coef_vec, nrow=1)}
if (length(x_index) >=2) {
coef_matrix <- lapply(node, function(x, node_index, coef_vec){matrix(coef_vec[, which(node_index==x)], nrow = nrow(coef_vec))}, node_index, coef_vec)
} else {
coef_matrix <- list(coef_vec)
}
return(coef_matrix)
}
data <- as.data.frame(dat)
node <- ncol(data)
# factorize each observation
for (i in 1:node){
level <- 0:(n_levels[i]-1)
data[,i] <- factor(data[,i],levels=level)
}
# get adjacency matrix
adjMatrix <- sparsebnUtils::get.adjacency.matrix(parents)
# subtract dependent and independent variables for each regression
coef <- vector("list", length = node)
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
estimation <- cd.run(databn, nlevels)
fit.coef <- fit_dag(estimation[[10]], nlevels, data)
parents <- estimation[[10]]
n_levels = nlevels
dat <- data
data <- as.data.frame(dat)
node <- ncol(data)
# factorize each observation
for (i in 1:node){
level <- 0:(n_levels[i]-1)
data[,i] <- factor(data[,i],levels=level)
}
# get adjacency matrix
adjMatrix <- sparsebnUtils::get.adjacency.matrix(parents)
# subtract dependent and independent variables for each regression
coef <- vector("list", length = node)
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
get_coef_matrix <- function(coef_vec, n_levels, x_index) {
node <- 1:length(x_index)
node_index <- rep(node, (n_levels-1))
if (!is.matrix(coef_vec)) {coef_vec <- matrix(coef_vec, nrow=1)}
if (length(x_index) >=2) {
coef_matrix <- lapply(node, function(x, node_index, coef_vec){matrix(coef_vec[, which(node_index==x)], nrow = nrow(coef_vec))}, node_index, coef_vec)
} else {
coef_matrix <- list(coef_vec)
}
return(coef_matrix)
}
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
fit_dag <- function(parents,
n_levels,
dat,
...) {
data <- as.data.frame(dat)
node <- ncol(data)
# factorize each observation
for (i in 1:node){
level <- 0:(n_levels[i]-1)
data[,i] <- factor(data[,i],levels=level)
}
# get adjacency matrix
adjMatrix <- sparsebnUtils::get.adjacency.matrix(parents)
# subtract dependent and independent variables for each regression
coef <- vector("list", length = node)
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
return(coef)
}
coef[[1]]
coef[[2]]
coef[[10]]
fit.coef <- fit_dag(parents, n_levels, dat)
library(discretecdAlgorithm)
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
estimation <- cd.run(databn, nlevels)
parents <- estimation[[10]]
fit.coef <- fit_dag(parents, nlevels, data)
get_coef_matrix <- function(coef_vec, n_levels, x_index) {
node <- 1:length(x_index)
node_index <- rep(node, (n_levels-1))
if (!is.matrix(coef_vec)) {coef_vec <- matrix(coef_vec, nrow=1)}
if (length(x_index) >=2) {
coef_matrix <- lapply(node, function(x, node_index, coef_vec){matrix(coef_vec[, which(node_index==x)], nrow = nrow(coef_vec))}, node_index, coef_vec)
} else {
coef_matrix <- list(coef_vec)
}
return(coef_matrix)
}
# A function to do inference in Bayesian network.
#' @export
fit_dag <- function(parents,
n_levels,
dat,
...) {
data <- as.data.frame(dat)
node <- ncol(data)
# factorize each observation
for (i in 1:node){
level <- 0:(n_levels[i]-1)
data[,i] <- factor(data[,i],levels=level)
}
# get adjacency matrix
adjMatrix <- sparsebnUtils::get.adjacency.matrix(parents)
# subtract dependent and independent variables for each regression
coef <- vector("list", length = node)
for (i in 1:node){
y <- data[, i]
x_ind <- which(adjMatrix[, i]==1)
if (length(x_ind)!=0) {
temp_data <- as.data.frame(cbind(y, data[, x_ind]))
fit <- nnet::multinom(y~.,data=temp_data, trace = FALSE)
coef_vec <- coef(fit)
temp_n_levels <- n_levels[x_ind]
intercept <- coef_vec[1]
coef_vec <- coef_vec[-1]
coef_seq <- get_coef_matrix(coef_vec, temp_n_levels, x_ind)
node_index <- 1:length(x_ind)
coef[[i]] <- lapply(node_index, function(x, coef_seq, x_ind){list(child=x_ind[x], coef=coef_seq[[x]])}, coef_seq, x_ind)
coef[[i]][[length(x_ind)+1]] <- list(intercept=intercept)
}
}
return(coef)
}
fit.coef <- fit_dag(parents, nlevels, data)
devtools::document()
fit.coef <- fit_dag(parents, nlevels, data)
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
# eor_nr <- node*(node-1)/2
# eor <- matrix(0, nrow=eor_nr, ncol=2)
# cnt1=1
# for (i in 1:(node-1)) {
#   for (j in (i+1):node) {
#     eor[cnt1, 1] = i;
#     eor[cnt1, 2] = j;
#     cnt1 = cnt1+1;
#   }
# }
# weights <- matrix(1, node, node)
# estimation <- CD.run(data, nlevels, eor, weights)
estimation <- cd.run(databn, nlevels)
parents <- estimation[[10]]
fit.coef <- fit_dag(parents, nlevels, data)
library(discretecdAlgorithm)
library(discretecdAlgorithm)
library(discretecdAlgorithm)
?sparsebnData
library(discretecdAlgorithm)
library(discretecdAlgorithm)
m <- matrix(c(0, 1, 1, 0, 0, 1, 0, 0, 0))
m <- matrix(c(0, 1, 1, 0, 0, 1, 0, 0, 0), 3, 3)
m
m!=0 && m!=1
m!=0 || m!=1
m!=0
m!=1
m[1, 2] = 2
m!=0 && m!=1
(m!=0) + (m!=1)
((m!=0) + (m!=1))!=1
library(discretecdAlgorithm)
library(discretecdAlgorithm)
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
estimation <- cd.run(databn, nlevels)
lambda_max <- max_lambda(databn, nlevels)
lambda_max
lambda_seq <- discretecdAlgorithm::generate.lambdas(lambda_max, 0.1)
estimation[[1]]$lambda
length(estimation)
estimation[[22]]$lambda
lambda_seq[[22]]
parents <- estimation[[10]]
fit.coef <- fit_dag(parents, nlevels, data)
?get.adjacency.matrix
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
class(parents)
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
is.edgeList(parents)
is.sparsebnFit(parents)
is.matrix(parents)
is.sparsebnFit(parents) || is.edgeList(parents)
is.sparsebnFit(parents) || is.edgeList(parents) || is.matrix(parents)
!(is.sparsebnFit(parents) || is.edgeList(parents) || is.matrix(parents))
!(is.edgeList(parents) || is.edgeList(parents) || is.matrix(parents))
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
length(fit.coef)
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
library(discretecdAlgorithm)
fit.coef <- fit_dag(parents, nlevels, data)
m <- matrix(1, 1, 1)
m
length(m)
m <- matrix(1, 2, 1)
length(m)
m
m <- matrix(1, 2, 2)
m
length(m)
dim(m)
library(discretecdAlgorithm)
coef_matrix <- matrix(rnorm(30), nrow=3)
coef_matrix
coef_matrix[, c(1, 3)]
dim(coef_matrix[, c(1, 3)])
n_node <- 6
n_levels <- c(2, 3, 4, 2, 3, 2)
coef_vec <- rnorm(10)
coef_matrix <- matrix(rnorm(30), nrow=3)
node <- 1:length(n_levels)
node_index <- rep(node, (n_levels-1))
node_index
library(discretecdAlgorithm)
rnorm(10)
matrix(c(2, 3, 12, 13, 22, 23), nrow=3, byrow = TRUE)
n_node <- 6
n_levels <- c(2, 3, 4, 2, 3, 2)
coef_vec <- 1:10
coef_matrix <- matrix(1:30, nrow=3)
coef.matrix.out <- get_coef_matrix(coef_matrix, n_levels)
coef.matrix.out <- discretecdAlgorithm:::get_coef_matrix(coef_matrix, n_levels)
coef.matrix.out[[2]]
coef_matrix
devtools::check()
devtools::check()
devtools::build_win()
estimateG <- as.matrix(get.adjacency.matrix(estimation[[20]]))
P = sum(estimateG)
E = sum(trueG*estimateG)
R = sum(trueG*t(estimateG))
FP = P - E - R
P; E; R; FP
# observational biparttite, n=100, p=100, data[101:200, ]
# [1] 76
# [1] 31
# [1] 29
# [1] 16
estimateG <- as.matrix(get.adjacency.matrix(estimation[[10]]))
P = sum(estimateG)
E = sum(trueG*estimateG)
R = sum(trueG*t(estimateG))
FP = P - E - R
P; E; R; FP
# observational biparttite, n=100, p=100, data[101:200, ]
# [1] 76
# [1] 31
# [1] 29
# [1] 16
?sparsebnData
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
databn$levels
nlevel <- unlist(databn$levels)
nlevel
nlevel <- as.vector(unlist(databn$levels))
class(nlevel)
estimation <- cd.run(databn)
library(discretecdAlgorithm)
estimation <- cd.run(databn)
library(discretecdAlgorithm)
library(discretecdAlgorithm)
library(discretecdAlgorithm)
data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/data.txt", quote="\"", comment.char="")
trueG <- read.table("~/Documents/STAT-COURSE/master thesis/revise/simulation/interventional/bipartite/test_100_2_1/trueG.txt", quote="\"", comment.char="")
# data <- read.table("~/Documents/STAT-COURSE/master thesis/revise/multinomial/small_network/test_6_5000/data.txt", quote="\"", comment.char="")
data <- data[101:200, ]
dataSize <- dim(data)[1]
node <- dim(data)[2]
nlevels <- rep(2, node)
ivn <- 1:node
ivn <- lapply(ivn, function(x){return(x)})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
# eor_nr <- node*(node-1)/2
# eor <- matrix(0, nrow=eor_nr, ncol=2)
# cnt1=1
# for (i in 1:(node-1)) {
#   for (j in (i+1):node) {
#     eor[cnt1, 1] = i;
#     eor[cnt1, 2] = j;
#     cnt1 = cnt1+1;
#   }
# }
# weights <- matrix(1, node, node)
# estimation <- CD.run(data, nlevels, eor, weights)
estimation <- cd.run(databn)
parents <- estimation[[10]]
fit.coef <- fit_dag(parents, nlevels, data)
estimateG <- as.matrix(get.adjacency.matrix(estimation[[10]]))
P = sum(estimateG)
E = sum(trueG*estimateG)
R = sum(trueG*t(estimateG))
FP = P - E - R
P; E; R; FP
devtools::check()
final <- cd.run(databn)
final.dag <- final[[length(final)]]
data <- matrix(c(1, 1, 0, 0, 1, 1,
1, 1, 0, 1, 1, 1,
0, 0, 1, 0, 0, 1,
0, 0, 1, 0, 0, 1,
0, 0, 0, 1, 1, 0,
0, 0, 0, 1, 1, 1,
1, 1, 1, 1, 0, 0,
1, 0, 1, 1, 0, 1,
0, 0, 0, 0, 1, 0,
1, 1, 1, 1, 0, 1,
1, 1, 0, 1, 1, 1,
0, 0, 1, 0, 0, 1,
1, 1, 0, 1, 0, 0,
1, 0, 1, 1, 0, 1,
1, 1, 1, 1, 1, 0,
1, 0, 1, 1, 1, 1,
0, 0, 1, 0, 0, 0,
1, 1, 0, 1, 1, 1,
1, 1, 1, 0, 0, 0,
1, 1, 1, 1, 0, 0,
0, 0, 0, 0, 1, 0,
0, 0, 1, 0, 0, 0,
1, 0, 0, 0, 1, 1,
0, 0, 1, 0, 0, 0,
1, 0, 1, 1, 0, 1,
0, 0, 0, 1, 1, 0,
0, 0, 0, 0, 0, 0,
0, 0, 1, 0, 1, 0,
0, 0, 1, 0, 0, 0,
0, 0, 1, 0, 0, 0), byrow = TRUE, ncol = 6)
dataSize <- dim(data)[1]
node <- dim(data)[2]
n_levels <- rep(2, node)
ivn <- vector("list", length = dataSize)
ivn <- lapply(ivn, function(x){return(as.integer(0))})
databn <- sparsebnUtils::sparsebnData(data, ivn = ivn, type = "discrete")
final <- cd.run(databn)
final.dag <- final[[length(final)]]
edge_list<- final.dag$edges
adj_matrix <- sparsebnUtils::get.adjacency.matrix(final.dag)
fit_dag(adj_matrix, n_levels, data)
class(adj_matrix)
is.matrix(adj_matrix)
adj_matrix
adj_Matrix==1
adj_matrix==1
which(adj_matrix==1)
which(adj_matrix[, 2]==1)
is.Matrix(adj_matrix)
class(edge_list)
Matrix::is.lgCMatrix(adj_matrix)
Matrix:::is.lgCMatrix(adj_matrix)
class(adj_matrix)=="dgCMatrix"
matrix <- matrix(adj_matrix, nrow = 6)
matrix
library(discretecdAlgorithm)
library(discretecdAlgorithm)
adj_list <- lapply(matrix, function(x){x})
adj_list
adj_list <- apply(matrix, function(x){x})
adj_list <- apply(matrix, 1, function(x){x})
adj_list
adj_list <- apply(matrix, 1, function(x){list(x)})
adj_list
matrix
out <- fit_dag(final.dag, n_levels, data)
out
length(out[[i]][[1]])
i=1
length(out[[i]][[1]])
length(out[[i]])
out[[4]]
out[[1]]
out[[1]][1]
out[[1]][1]$parent
out[[1]][[1]]
dim(out[[1]][[1]]$parent)
dim(out[[1]][[1]]$coef)
out[[1]][[1]]$parent
dim(out[[1]][[4]])
out[[1]][[4]]
out[[1]]
devtools::check()
devtools::build_win()
