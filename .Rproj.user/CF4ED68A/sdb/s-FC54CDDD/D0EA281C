{
    "collab_server" : "",
    "contents" : "#\n#  s3-SparseBlockMatrixR.R\n#  ccdrAlgorithm\n#\n#  Created by Bryon Aragam (local) on 1/22/16.\n#  Copyright (c) 2014-2016 Bryon Aragam. All rights reserved.\n#\n\n#------------------------------------------------------------------------------#\n# SparseBlockMatrixR S3 Class for R\n#------------------------------------------------------------------------------#\n\n#\n# SparseBlockMatrixR S3 class skeleton\n#\n# Data\n# * list rows\n# * list vals\n# * list blocks\n# * numeric sigmas\n# * integer start\n#\n\n#\n# A convenience class to make sharing data between R and C++ easier. This class mimics the structure\n#   of the C++ class 'SparseBlockMatrix' (note the name difference to differentiate the two) as a list in R,\n#   which makes it easy to use Rcpp to pass a sparse structure between R and C++. This class is NOT intended\n#   to be a general purpose sparse data structure for R; instead, it simply streamlines the connection between\n#   R and C++.\n#\n# A SparseBlockMatrixR object consists of four main components:\n#   1) rows - a list of integer vectors\n#   2) vals - a list of numeric vectors\n#   3) blocks - a list of integer vectors\n#   4) sigmas - a numeric vector\n#\n# There is also a fifth component which identifies whether the indexing in the object begins at 0 or 1.\n#   This is needed for bookkeeping and ensuring coherent translation between R and C++.\n#   5) start - 0 or 1\n#\n# These components all exactly reflect their purpose in SparseBlockMatrix.h; see that file for more details.\n#\n#   NOTES:\n#       1) Since C++ begins indexing at 0, we have included two functions for re-indexing between the two conventions,\n#          defined in reIndexR and reIndexC. The 'start' flag ensures we keep track of where indexing begins.\n#\n#\n\n#------------------------------------------------------------------------------#\n# is.SparseBlockMatrixR\n#\nis.SparseBlockMatrixR <- function(sbm){\n    inherits(sbm, \"SparseBlockMatrixR\")\n} # END IS.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# reIndexC.SparseBlockMatrixR\n#  Re-indexing TO C for SparseBlockMatrixR objects\n#\nreIndexC.SparseBlockMatrixR <- function(sbm){\n    #\n    # Using lapply does NOT work here: if one of the list elements is an empty vector, adding 1 will\n    #  mysteriously coerce it to a numeric vector (should be integer!). Not sure why this happens, but\n    #  we shouldn't allow R to secretly change our data types without our permission. Use a for loop\n    #  instead.\n    #\n    # UPDATE 05/13/14: Using '1L' keeps everything as an integer. This makes sense since '1' is a numeric\n    #                   literal in R, while the corresponding literal for an integer is '1L'.\n    #\n    sbm$rows <- lapply(sbm$rows, function(x){ x - 1L})\n    if(length(sbm$blocks) > 0) sbm$blocks <- lapply(sbm$blocks, function(x){ x - 1L})\n\n    sbm$start <- 0\n\n    sbm\n} # END REINDEXC.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# reIndexR.SparseBlockMatrixR\n#  Re-indexing TO R for SparseBlockMatrixR objects\n#\nreIndexR.SparseBlockMatrixR <- function(sbm){\n    #\n    # Using lapply does NOT work here: if one of the list elements is an empty vector, adding 1 will\n    #  coerce it to a numeric vector (should be integer!). Using '1L' keeps everything as an integer.\n    #  This makes sense since '1' is a numeric literal in R, while the corresponding literal for an\n    #  integer is '1L'.\n    #\n    sbm$rows <- lapply(sbm$rows, function(x){ x + 1L})\n    if(length(sbm$blocks) > 0) sbm$blocks <- lapply(sbm$blocks, function(x){ x + 1L})\n\n    sbm$start <- 1\n\n    sbm\n} # END REINDEXR.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# SparseBlockMatrixR.list\n#  List constructor\n#\nSparseBlockMatrixR.list <- function(li){\n\n    if( !is.list(li)){\n        stop(\"Input must be a list!\")\n    }\n\n    if( length(li) != 5 || !setequal(names(li), c(\"rows\", \"vals\", \"blocks\", \"sigmas\", \"start\"))){\n        stop(\"Input is not coercable to an object of type SparseBlockMatrixR, check list for the following elements: rows (list), vals (list), blocks (list), sigmas (numeric), start (integer)\")\n    }\n\n    if(!is.list(li$rows) || !is.list(li$vals)){\n        stop(\"rows and vals must both be lists of length pp!\")\n    }\n\n    if( length(li$rows) != length(li$vals)){\n        #\n        # We enforce that rows and vals must have the same length, but relax this assumption for blocks and sigmas\n        #  since they are mostly internal to the CCDr algorithm, and once the algorithm has run we may want to free\n        #  up the memory associated with these elements\n        #\n        stop(\"rows and vals have different sizes; should all have the same length (pp)!!\")\n    }\n\n    structure(li, class = \"SparseBlockMatrixR\")\n} # END SPARSEBLOCKMATRIXR.LIST\n\n#------------------------------------------------------------------------------#\n# SparseBlockMatrixR.sparse\n#  sparse object constructor\n#\nSparseBlockMatrixR.sparse <- function(sp){\n\n    if( !sparsebnUtils::is.sparse(sp)){\n        stop(\"Input must be a sparse object!\")\n    } else if(sp$dim[1] != sp$dim[2]){\n        stop(\"Input must be square!\")\n    }\n\n    pp <- sp$dim[1]\n    if(sp$start == 0) sp <- sparsebnUtils::reIndexR(sp) # re-index rows and cols to start at 1 if necessary\n\n    sbm.rows <- vector(\"list\", length = pp)\n    sbm.vals <- vector(\"list\", length = pp)\n    sbm.blocks <- vector(\"list\", length = pp)\n\n    warning(\"Attempting to coerce sparse object to SparseBlockMatrixR with no data for sigmas: \\n   Setting sigma_j = 0 by default.\")\n    sbm.sigmas <- rep(0, pp) ### 2015-03-25: check this default!\n\n    # how to vectorize this???\n    for(j in 1:pp){\n        # Clear out the jth entry in the lists to be an empty vector\n        sbm.rows[[j]] <- integer(0)\n        sbm.vals[[j]] <- numeric(0)\n        sbm.blocks[[j]] <- integer(0)\n    }\n\n    for(j in 1:pp){\n\n        thisColIdx <- which(sp$cols == j)\n        rows <- as.integer(sp$rows[thisColIdx])\n        for(k in seq_along(rows)){\n            row <- rows[k]\n\n            sbm.rows[[j]] <- c(sbm.rows[[j]], row)\n            sbm.rows[[row]] <- c(sbm.rows[[row]], j)\n\n            sbm.vals[[j]] <- c(sbm.vals[[j]], sp$vals[thisColIdx[k]])\n            sbm.vals[[row]] <- c(sbm.vals[[row]], 0)\n\n            # vals[rows[j][k]][block[j][k]] = beta_ji\n            sbm.blocks[[j]] <- c(sbm.blocks[[j]], length(sbm.rows[[row]]))\n            sbm.blocks[[row]] <- c(sbm.blocks[[row]], length(sbm.rows[[j]]))\n        }\n\n    }\n\n    names(sbm.rows) <- names(sbm.vals) <- names(sbm.blocks) <- as.character(1:pp)\n\n    #\n    # NOTE: We use R-indexing by default. This can be changed by using reIndexC if necessary.\n    #\n    SparseBlockMatrixR.list(list(rows = sbm.rows, vals = sbm.vals, blocks = sbm.blocks, sigmas = sbm.sigmas, start = 1))\n} # END SPARSEBLOCKMATRIXR.SPARSE\n\n#------------------------------------------------------------------------------#\n# SparseBlockMatrixR.matrix\n#  matrix constructor\n#\nSparseBlockMatrixR.matrix <- function(m){\n\n    if(nrow(m) != ncol(m)) stop(\"Input matrix must be square!\")\n\n    sp <- sparsebnUtils:::as.sparse(m)\n\n    SparseBlockMatrixR.sparse(sp)\n} # END SPARSEBLOCKMATRIXR.MATRIX\n\n#------------------------------------------------------------------------------#\n# as.SparseBlockMatrixR.list\n#  Convert FROM list TO SparseBlockMatrixR\n#\nas.SparseBlockMatrixR.list <- function(li){\n    SparseBlockMatrixR.list(li)\n} # END AS.SPARSEBLOCKMATRIXR.LIST\n\n#------------------------------------------------------------------------------#\n# as.SparseBlockMatrixR.sparse\n#  Convert FROM sparse TO SparseBlockMatrixR\n#\nas.SparseBlockMatrixR.sparse <- function(sp){\n    SparseBlockMatrixR.sparse(sp)\n} # END AS.SPARSEBLOCKMATRIXR.SPARSE\n\n#------------------------------------------------------------------------------#\n# as.SparseBlockMatrixR.matrix\n#  Convert FROM matrix TO SparseBlockMatrixR\n#\nas.SparseBlockMatrixR.matrix <- function(m){\n    SparseBlockMatrixR.matrix(m)\n} # END AS.SPARSEBLOCKMATRIXR.MATRIX\n\n#------------------------------------------------------------------------------#\n# as.list.SparseBlockMatrixR\n#  Convert FROM SparseBlockMatrixR TO list\n#  Even though internally the SBM object is a list, we must still manually define this function\n#\nas.list.SparseBlockMatrixR <- function(sbm){\n    list(rows = sbm$rows, vals = sbm$vals, blocks = sbm$blocks, sigmas = sbm$sigmas, start = sbm$start)\n} # END AS.LIST.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# as.matrix.SparseBlockMatrixR\n#  Convert FROM SparseBlockMatrixR TO matrix\n#\nas.matrix.SparseBlockMatrixR <- function(sbm){\n    pp <- length(sbm$rows)\n    m <- matrix(0, nrow = pp, ncol = pp)\n\n    ### 2015-03-02: Why was I using diag to construct this matrix?\n    # m <- diag(rep(0, pp))\n\n    if(sbm$start == 0) sbm <- sparsebnUtils::reIndexR(sbm)\n\n    for(j in 1:pp){\n        m[sbm$rows[[j]], j] <- sbm$vals[[j]]\n    }\n\n    ### 2015-03-02: Do not need to set dim attribute of matrix! (Already set by default constructor)\n    # attributes(m)$dim <- c(pp, pp)\n    # attributes(m)$dimnames <- list()\n    rownames(m) <- as.character(1:nrow(m))\n    colnames(m) <- as.character(1:ncol(m))\n\n    m\n} # END AS.MATRIX.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# as.edgeList.SparseBlockMatrixR\n# Coerce SBM to edge list\n#\nas.edgeList.SparseBlockMatrixR <- function(sbm){\n    #\n    # We have to be careful in obtaining the edge list of a SparseBlockMatrixR object:\n    #  It is NOT the same as the rows slot since some of these components may have\n    #  zero edge weights (see docs for SparseBlockMatrixR for explanation). Thus, in\n    #  order to obtain the edge list, we need to check which indices in the rows slot\n    #  have nonzero edge weights.\n    #\n    # y = rows, x = vals : Select the elements of rows which have nonzero values in vals,\n    #                       accouting for possible round-off (hence .MACHINE_EPS).\n    #\n    el <- mapply(function(x, y){ y[which(abs(x) > sparsebnUtils:::.MACHINE_EPS)]}, sbm$vals, sbm$rows)\n\n    sparsebnUtils::edgeList(el)\n} # AS.EDGELIST.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# sparse.SparseBlockMatrixR\n# 2016-01-22: Migrated to this file from s3-sparse.R\n#\nsparse.SparseBlockMatrixR <- function(sbm, index = \"R\"){\n\n    if(index != \"R\" && index != \"C\") stop(\"Invalid entry for index parameter: Must be either 'R' or 'C'!\")\n\n    pp <- length(sbm$rows)\n\n    sp.rows <- integer(0)\n    sp.cols <- integer(0)\n    sp.vals <- numeric(0)\n\n    sp.idx <- 0\n    for(j in 1:pp){\n        these.rows <- sbm$rows[[j]]\n        these.vals <- sbm$vals[[j]]\n        for(k in seq_along(these.rows)){\n\n            # Only include nonzero values\n            if(these.vals[k] != 0){\n                sp.idx <- sp.idx + 1\n\n                sp.rows <- c(sp.rows, these.rows[k])\n                sp.cols <- c(sp.cols, j)\n                sp.vals <- c(sp.vals, these.vals[k])\n            }\n        }\n    }\n\n    sp <- sparsebnUtils::sparse(list(rows = as.integer(sp.rows), cols = as.integer(sp.cols), vals = sp.vals, dim = c(pp, pp), start = 1))\n\n    if(index == \"R\"){\n        sp\n    } else{\n        sp$start <- 0\n        sparsebnUtils::reIndexC(sp)\n    }\n} # END SPARSE.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# as.sparse.SparseBlockMatrixR\n#  Convert FROM SparseBlockMatrixR TO sparse\n#  By default, return the object using R indexing. If desired, the method can return C-style indexing by setting\n#    index = \"C\".\n# 2016-01-22: Migrated to this file from s3-sparse.R\n#\nas.sparse.SparseBlockMatrixR <- function(sbm, index = \"R\"){\n    sparse.SparseBlockMatrixR(sbm, index)\n} # END AS.SPARSE.SPARSEBLOCKMATRIXR\n\n# to_graphNEL.SparseBlockMatrixR\n#  Convert SBM object to graphNEL object\nto_graphNEL.SparseBlockMatrixR <- function(sbm){\n    el <- sparsebnUtils::as.edgeList(sbm)\n    el <- to_graphNEL(el)\n\n    graphNEL(nodes = as.character(1:num.nodes(sbm)), edgeL = el, edgemode = 'directed')\n} # END TO_GRAPHNEL.SPARSEBLOCKMATRIXR\n\nget.adjacency.matrix.SparseBlockMatrixR <- function(sbm){\n    sparsebnUtils::get.adjacency.matrix(as.edgeList.SparseBlockMatrixR(sbm))\n} # END GET.ADJACENCY.MATRIX.SPARSEBLOCKMATRIXR\n\nnum.nodes.SparseBlockMatrixR <- function(sbm){\n    ### The number of nodes should be exactly the same as the length of the rows list\n    length(sbm$rows)\n} # END NUM.NODES.SPARSEBLOCKMATRIXR\n\nnum.edges.SparseBlockMatrixR <- function(sbm){\n    ### The number of nodes should be exactly the same as the length of the rows list\n    sparsebnUtils::num.edges(as.edgeList.SparseBlockMatrixR(sbm))\n} # END NUM.EDGES.SPARSEBLOCKMATRIXR\n\n# This function is (so far) only used in unit tests\nis.zero.SparseBlockMatrixR <- function(x){\n    check_if_zero <- (length(unlist(x$sbm$rows)) == 0)\n\n    check_if_zero\n} # END IS.ZERO.SPARSEBLOCKMATRIXR\n\n#------------------------------------------------------------------------------#\n# .init_sbm\n# Internal function for initializing a SparseBlockMatrixR object directly\n#  from a matrix AND a sigmas vector\n#\n.init_sbm <- function(init_matrix, init_sigmas){\n    stopifnot(sparsebnUtils::check_if_matrix(init_matrix))\n    stopifnot(nrow(init_matrix) == ncol(init_matrix))\n\n    stopifnot(is.numeric(init_sigmas))\n    stopifnot(length(init_sigmas) == nrow(init_matrix))\n\n    sbm <- suppressWarnings(SparseBlockMatrixR(init_matrix)) # suppress warnings since we are working in a controlled environment\n    sbm$sigmas <- init_sigmas\n\n    sbm\n} # END .INIT_SBM\n\n#------------------------------------------------------------------------------#\n# .to_B.SparseBlockMatrixR\n# Internal function to convert estimates from the (Rho, R) parametrization to\n#  the standard (B, Omega) parametrization.\n#\nto_B.SparseBlockMatrixR <- function(sbm){\n    ### Need to re-parametrize the betas FIRST\n    sbm$vals <- mapply(function(x, y) x/y, sbm$vals, sbm$sigmas) # Divide each vals vector by sigmas[j]\n    sbm$sigmas <- 1/ (sbm$sigmas)^2\n\n    sbm\n}\n",
    "created" : 1460592189277.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2789007484",
    "id" : "D0EA281C",
    "lastKnownWriteTime" : 1460489618,
    "path" : "~/Documents/STAT-COURSE/qualify/ccdrAlgorithm/R/s3-SparseBlockMatrixR.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}