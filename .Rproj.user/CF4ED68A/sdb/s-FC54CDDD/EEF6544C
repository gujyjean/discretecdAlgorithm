{
    "collab_server" : "",
    "contents" : "#\n#  ccdr-main-R.R\n#  ccdrAlgorithm\n#\n#  Created by Bryon Aragam (local) on 1/22/16.\n#  Copyright (c) 2014-2016 Bryon Aragam. All rights reserved.\n#\n\n#\n# PACKAGE CCDRALGORITHM: Main CCDr methods\n#\n#   CONTENTS:\n#     ccdr.run\n#     ccdr_call\n#     ccdr_gridR\n#     ccdr_singleR\n#\n\n###--- These two lines are necessary to import the auto-generated Rcpp methods in RcppExports.R---###\n#' @useDynLib ccdrAlgorithm\n#' @importFrom Rcpp sourceCpp\nNULL\n\n#' Main CCDr Algorithm\n#'\n#' Estimate a Bayesian network (directed acyclic graph) from observational data using the\n#' CCDr algorithm as described in \\href{http://arxiv.org/abs/1401.0852}{Aragam and Zhou (2015), JMLR}.\n#'\n#' Instead of producing a single estimate, this algorithm computes a solution path of estimates based\n#' on the values supplied to \\code{lambdas} or \\code{lambdas.length}. The CCDr algorithm approximates\n#' the solution to a nonconvex optimization problem using coordinate descent. Instead of AIC or BIC,\n#' CCDr uses continuous regularization based on concave penalties such as the minimax concave penalty\n#' (MCP).\n#'\n#' This implementation includes two options for the penalty: (1) MCP, and (2) L1 (or Lasso). This option\n#' is controlled by the \\code{gamma} argument.\n#'\n#' @param data Data matrix. Must be numeric and contain no missing values.\n#' @param betas Initial guess for the algorithm. Represents the weighted adjacency matrix\n#'              of a DAG where the algorithm will begin searching for an optimal structure.\n#' @param lambdas (optional) Numeric vector containing a grid of lambda values (i.e. regularization\n#'                parameters) to use in the solution path. If missing, a default grid of values will be\n#'                used based on a decreasing log-scale  (see also \\link{generate.lambdas}).\n#' @param lambdas.length Integer number of values to include in the solution path. If \\code{lambdas}\n#'                       has also been specified, this value will be ignored. Note also that the final\n#'                       solution path may contain fewer estimates (see\n#'                       \\code{alpha}).\n#' @param gamma Value of concavity parameter. If \\code{gamma > 0}, then the MCP will be used\n#'              with \\code{gamma} as the concavity parameter. If \\code{gamma < 0}, then the L1 penalty\n#'              will be used and this value is otherwise ignored.\n#' @param error.tol Error tolerance for the algorithm, used to test for convergence.\n#' @param max.iters Maximum number of iterations for each internal sweep.\n#' @param alpha Threshold parameter used to terminate the algorithm whenever the number of edges in the\n#'              current estimation is \\code{> alpha * ncol(data)}.\n#' @param verbose \\code{TRUE / FALSE} whether or not to print out progress and summary reports.\n#'\n#' @return A \\code{\\link[sparsebnUtils]{sparsebnPath}} object.\n#'\n#' @examples\n#'\n#' \\dontrun{\n#'\n#' ### Generate some random data\n#' dat <- matrix(rnorm(1000), nrow = 20)\n#'\n#' ### Run with default settings\n#' ccdr.run(data = dat)\n#'\n#' ### Optional: Adjust settings\n#' pp <- ncol(dat)\n#' init.betas <- matrix(0, nrow = pp, ncol = pp)              # initialize algorithm with a random initial value\n#' init.betas[1,2] <- init.betas[1,3] <- init.betas[4,2] <- 1 #\n#' ccdr.run(data = dat, betas = init.betas, lambdas.length = 10, alpha = 10, verbose = TRUE)\n#' }\n#'\n#' @export\nccdr.run <- function(data,\n                     betas,\n                     lambdas,\n                     lambdas.length = NULL,\n                     gamma = 2.0,\n                     error.tol = 1e-4,\n                     max.iters = NULL,\n                     alpha = 10,\n                     verbose = FALSE\n){\n    ### This is just a wrapper for the internal implementation given by ccdr_call\n    ccdr_call(data = data,\n              betas = betas,\n              lambdas = lambdas,\n              lambdas.length = lambdas.length,\n              gamma = gamma,\n              error.tol = error.tol,\n              rlam = NULL,\n              max.iters = max.iters,\n              alpha = alpha,\n              verbose = verbose)\n} # END CCDR.RUN\n\n# ccdr_call\n#\n#   Handles most of the bookkeeping for CCDr. Sets default values and prepares arguments for\n#    passing to ccdr_gridR and ccdr_singleR. Some type-checking as well, although most of\n#    this is handled internally by ccdr_gridR and ccdr_singleR.\n#\nccdr_call <- function(data,\n                      betas,\n                      lambdas,\n                      lambdas.length,\n                      gamma,\n                      error.tol,\n                      rlam,\n                      max.iters,\n                      alpha,\n                      verbose = FALSE\n){\n    ### Allow users to input a data.frame, but kindly warn them about doing this\n    if(is.data.frame(data)){\n        warning(sparsebnUtils::alg_input_data_frame())\n        data <- sparsebnUtils::sparsebnData.data.frame(data)\n    }\n\n    ### Check data format\n    if(!sparsebnUtils::is.sparsebnData(data)) stop(sparsebnUtils::input_not_sparsebnData(data))\n\n    ### Extract the data (CCDr only works on observational data, so ignore the intervention part)\n    data_matrix <- data$data\n\n    # Could use check_if_complete_data here, but we avoid this in order to save a (small) amount of computation\n    #  and give a more informative error message\n    num_missing_values <- sparsebnUtils::count_nas(data_matrix)\n    if(num_missing_values > 0) stop(sprintf(\"%d missing values detected!\", num_missing_values))\n\n    ### Get the dimensions of the data matrix\n    nn <- as.integer(nrow(data_matrix))\n    pp <- as.integer(ncol(data_matrix))\n\n    ### Use default values for lambda if not specified\n    if(missing(lambdas)){\n        if(is.null(lambdas.length)){\n            stop(\"Both lambdas and lambdas.length unspecified: Must specify a value for at least one of these arguments!\")\n        } else{\n            ### Check lambdas.length if specified\n            if(!is.numeric(lambdas.length)) stop(\"lambdas.length must be numeric!\")\n            if(lambdas.length <= 0) stop(\"lambdas.length must be positive!\")\n        }\n\n        if(missing(rlam)){\n            ### Even though ccdr_call should never be called on its own, this behaviour is left for testing backwards-compatibility\n            stop(\"rlam must be specified if lambdas is not explicitly specified.\")\n        } else if(is.null(rlam)){\n            ### rlam = NULL is used as a sentinel value to indicate a default value should be used\n            rlam <- 1e-2\n        } else{\n            ### Check rlam if specified\n            if(!is.numeric(rlam)) stop(\"rlam must be numeric!\")\n            if(rlam < 0) stop(\"rlam must be >= 0!\")\n        }\n\n        # If no grid of lambdas is passed, then use the standard log-scale that starts at\n        #  max.lam = sqrt(nn) and descends to min.lam = rlam * max.lam\n        lambdas <- sparsebnUtils::generate.lambdas(lambda.max = sqrt(nn),\n                                                   lambdas.ratio = rlam,\n                                                   lambdas.length = as.integer(lambdas.length),\n                                                   scale = \"log\")\n    }\n\n    ### Check lambdas\n    if(!is.numeric(lambdas)) stop(\"lambdas must be a numeric vector!\")\n    if(any(lambdas < 0)) stop(\"lambdas must contain only nonnegative values!\")\n\n#     if(length(lambdas) != lambdas.length){\n#         warning(\"Length of lambdas vector does not match lambdas.length. The specified lambdas vector will be used and lambdas.length will be overwritten.\")\n#     }\n\n    ### By default, set the initial guess for betas to be all zeroes\n    if(missing(betas)){\n        betas <- matrix(0, nrow = pp, ncol = pp)\n        # betas <- SparseBlockMatrixR(betas) # 2015-03-26: Deprecated and replaced with .init_sbm below\n        betas <- .init_sbm(betas, rep(0, pp))\n\n        # If the initial matrix is the zero matrix, indexing does not matter so we don't need to use reIndexC here\n        #   Still need to set start = 0, though.\n        betas$start <- 0\n    } # Type-checking for betas happens in ccdr_singleR\n\n    # This parameter can be set by the user, but in order to prevent the algorithm from taking too long to run\n    #  it is a good idea to keep the threshold used by default which is O(sqrt(pp))\n    if(is.null(max.iters)){\n        max.iters <- 2 * max(10, sqrt(pp))\n    }\n\n    t1.cor <- proc.time()[3]\n    #     cors <- cor(data_matrix)\n    #     cors <- cors[upper.tri(cors, diag = TRUE)]\n    cors <- sparsebnUtils::cor_vector(data_matrix)\n    t2.cor <- proc.time()[3]\n\n    fit <- ccdr_gridR(cors,\n                      as.integer(pp),\n                      as.integer(nn),\n                      betas,\n                      as.numeric(lambdas),\n                      as.numeric(gamma),\n                      as.numeric(error.tol),\n                      as.integer(max.iters),\n                      as.numeric(alpha),\n                      verbose)\n\n    #\n    # Output DAGs as edge lists (i.e. edgeList objects).\n    #  This is NOT the same as sbm$rows since some of these rows may correspond to edges with zero coefficients.\n    #  See docs for SparseBlockMatrixR class for details.\n    #\n    for(k in seq_along(fit)){\n        names(fit[[k]])[1] <- \"edges\" # rename 'sbm' slot to 'edges': After the next line, this slot will no longer be an SBM object\n        fit[[k]]$edges <- sparsebnUtils::as.edgeList(fit[[k]]$edges) # Before coercion, li$edges is actually an SBM object\n    }\n\n    fit <- lapply(fit, sparsebnUtils::sparsebnFit)    # convert everything to sparsebnFit objects\n    sparsebnUtils::sparsebnPath(fit)                  # wrap as sparsebnPath object\n} # END CCDR_CALL\n\n# ccdr_gridR\n#\n#   Main subroutine for running the CCDr algorithm on a grid of lambda values.\nccdr_gridR <- function(cors,\n                       pp, nn,\n                       betas,\n                       lambdas,\n                       gamma,\n                       eps,\n                       maxIters,\n                       alpha,\n                       verbose\n){\n\n    ### Check alpha\n    if(!is.numeric(alpha)) stop(\"alpha must be numeric!\")\n    if(alpha < 0) stop(\"alpha must be >= 0!\")\n\n    ### nlam is now set automatically\n    nlam <- length(lambdas)\n\n    ccdr.out <- list()\n    for(i in 1:nlam){\n        if(verbose) message(\"Working on lambda = \", round(lambdas[i], 5), \" [\", i, \"/\", nlam, \"]\")\n\n        t1.ccdr <- proc.time()[3]\n        ccdr.out[[i]] <- ccdr_singleR(cors,\n                                      pp, nn,\n                                      betas,\n                                      lambdas[i],\n                                      gamma = gamma,\n                                      eps = eps,\n                                      maxIters = maxIters,\n                                      alpha = alpha,\n                                      verbose = verbose\n        )\n        t2.ccdr <- proc.time()[3]\n\n        betas <- ccdr.out[[i]]$sbm\n        betas <- sparsebnUtils::reIndexC(betas) # use C-friendly indexing\n\n        if(verbose){\n            test.nedge <- sum(as.matrix(betas) != 0)\n            message(\"  Estimated number of edges: \", ccdr.out[[i]]$nedge, \" / test = \", test.nedge)\n            # message(\"  Estimated total variance: \", sum(1 / (betas$sigmas)^2))\n        }\n\n        # 7-16-14: Added code below to check edge threshold via alpha parameter\n        if(ccdr.out[[i]]$nedge > alpha * pp){\n            if(verbose) message(\"Edge threshold met, terminating algorithm with \", ccdr.out[[i-1]]$nedge, \" edges.\")\n            break\n        }\n    }\n\n    ccdr.out[1:(i-1)] # only return up to i - 1 since the last (ith) model would not have finished running anyway\n} # END CCDR_GRIDR\n\n# ccdr_singleR\n#\n#   Internal subroutine for handling calls to singleCCDr: This is the only place where C++ is directly\n#    called. Type-checking is strongly enforced here.\nccdr_singleR <- function(cors,\n                         pp, nn,\n                         betas,\n                         lambda,\n                         gamma,\n                         eps,\n                         maxIters,\n                         alpha,     # 2-9-15: No longer necessary in ccdr_singleR, but needed since the C++ call asks for it\n                         verbose = FALSE\n){\n\n    ### Check cors\n    if(!is.numeric(cors)) stop(\"cors must be a numeric vector!\")\n    if(length(cors) != pp*(pp+1)/2) stop(paste0(\"cors has incorrect length: Expected length = \", pp*(pp+1)/2, \" input length = \", length(cors)))\n\n    ### Check dimension parameters\n    if(!is.integer(pp) || !is.integer(nn)) stop(\"Both pp and nn must be integers!\")\n    if(pp <= 0 || nn <= 0) stop(\"Both pp and nn must be positive!\")\n\n    ### Check betas\n    if(sparsebnUtils::check_if_matrix(betas)){ # if the input is a matrix, convert to SBM object\n        betas <- SparseBlockMatrixR(betas) # if betas is non-numeric, SparseBlockMatrixR constructor should throw error\n        betas <- reIndexC(betas) # use C-friendly indexing\n    } else if(!is.SparseBlockMatrixR(betas)){ # otherwise check that it is an object of class SparseBlockMatrixR\n        stop(\"Incompatible data passed for betas parameter: Should be either matrix or list in SparseBlockMatrixR format.\")\n    }\n\n    ### Check lambda\n    if(!is.numeric(lambda)) stop(\"lambda must be numeric!\")\n    if(lambda < 0) stop(\"lambda must be >= 0!\")\n\n    ### Check gamma\n    if(!is.numeric(gamma)) stop(\"gamma must be numeric!\")\n    if(gamma < 0 && gamma != -1) stop(\"gamma must be >= 0 (MCP) or = -1 (Lasso)!\")\n\n    ### Check eps\n    if(!is.numeric(eps)) stop(\"eps must be numeric!\")\n    if(eps <= 0){\n        if(eps < 0) stop(\"eps must be >= 0!\")\n        if(eps == 0) warning(\"eps is set to zero: This may cause the algorithm to fail to converge, and maxIters will be used to terminate the algorithm.\")\n    }\n\n    ### Check maxIters\n    if(!is.integer(maxIters)) stop(\"maxIters must be an integer!\")\n    if(maxIters <= 0) stop(\"maxIters must be > 0!\")\n\n    ### alpha check is in ccdr_gridR\n\n    # if(verbose) cat(\"Opening C++ connection...\")\n    t1.ccdr <- proc.time()[3]\n    ccdr.out <- singleCCDr(cors,\n                           betas,\n                           nn,\n                           lambda,\n                           c(gamma, eps, maxIters, alpha),\n                           verbose = verbose)\n    t2.ccdr <- proc.time()[3]\n    # if(verbose) cat(\"C++ connection closed. Total time in C++: \", t2.ccdr-t1.ccdr, \"\\n\")\n\n    #\n    # Convert output back to SBM format\n    #\n    ccdr.out <- list(sbm = SparseBlockMatrixR(list(rows = ccdr.out$rows, vals = ccdr.out$vals, blocks = ccdr.out$blocks, sigmas = ccdr.out$sigmas, start = 0)),\n                     lambda = ccdr.out$lambda,\n                     nedge = ccdr.out$length,\n                     pp = pp,\n                     nn = nn,\n                     time = t2.ccdr - t1.ccdr)\n    ccdr.out$sbm <- sparsebnUtils::reIndexR(ccdr.out$sbm)\n\n    # sparsebnFit(ccdr.out)\n    ccdr.out\n} # END CCDR_SINGLER\n",
    "created" : 1460498360414.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2665404010",
    "id" : "EEF6544C",
    "lastKnownWriteTime" : 1460489618,
    "path" : "~/Documents/STAT-COURSE/qualify/ccdrAlgorithm/R/ccdrAlgorithm-main.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}