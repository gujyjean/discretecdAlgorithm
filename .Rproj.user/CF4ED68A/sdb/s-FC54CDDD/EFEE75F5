{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include \"dBasic.h\"\n#include \"dCD.h\"\n#include \"type.h\"\n#include <iostream>\nusing namespace Rcpp;\n\n\n// This is a simple example of exporting a C++ function to R. You can\n// source this function into an R session using the Rcpp::sourceCpp\n// function (or via the Source button on the editor toolbar). Learn\n// more about Rcpp at:\n//\n//   http://www.rcpp.org/\n//   http://adv-r.had.co.nz/Rcpp.html\n//   http://gallery.rcpp.org/\n//\n\n#include <RcppEigen.h>\n\n// [[Rcpp::depends(RcppEigen)]]\nusing namespace Eigen;\n// using Rcpp::as;\ntypedef Map<MatrixXd> MapMatd;\ntypedef Map<MatrixXi> MapMati;\ntypedef Map<VectorXd> MapVecd;\ntypedef Map<VectorXi> MapVeci;\n\n\n// [[Rcpp::export]]\nList CD( int node,\n                    int dataSize,\n                    Eigen::Map<Eigen::MatrixXi> data,\n                    Eigen::Map<Eigen::VectorXi> nlevels,\n                    List obsIndex_R,\n                    int eor_nr,\n                    Eigen::Map<Eigen::MatrixXi> eor,\n                    double fmlam,\n                    int nlam,\n                    double eps,\n                    double convLb,\n                    double qtol,\n                    Eigen::Map<Eigen::MatrixXd> weights,\n                    double gamma,\n                    double upperbound\n) {\n\n  // convert Rcpp type to C++ type\n  // construct obsIndex\n VectorXVXi obsIndex(node);\n for (int i=0; i<node; i++) {\n   obsIndex(i) = obsIndex_R[i];\n }\n\n  // construct levelIndex\n  MatrixXVXi levelIndex(node, node);\n  for (int i=0; i<node; i++) {\n    for (int j=0; j<node; j++) {\n      if (j != i) {\n        levelIndex(j, i).resize(nlevels[j] - 1);\n        for (int k=0; k<(nlevels[j]-1); k++) {\n          levelIndex(j, i)(k) = k;\n        }\n      }\n      else {\n        levelIndex(j, i).resize(nlevels[j]);\n        for (int k=0; k<nlevels[j]; k++) {\n          levelIndex(j, i)(k) = k;\n        }\n      }\n    }\n  }\n\n  MatrixXMXd betaM(node+1, node);\n  MatrixXMXd betaN(nlam*(node+1), node);\n  Eigen::MatrixXi estimateG = Eigen::MatrixXi::Zero(node*nlam, node);\n  Eigen::VectorXd lambdaSeq(nlam), log_like(nlam), dur(nlam);\n  for (int i = 0; i < nlam; i++) {\n    log_like(i) = 0.0;\n    dur(i) = 0.0;\n  }\n\n  // Eigen::MatrixXi t_data(Rcpp::as< MapMati >(data));\n  Eigen::MatrixXi t_data(dataSize, node);\n  for (int i=0; i<dataSize; i++) {\n    for (int j=0; j<node; j++) {\n      t_data(i, j) = data(i, j);\n    }\n  }\n  Eigen::MatrixXd t_weights(node, node);\n  for (int i=0; i<node; i++) {\n    for (int j=0; j<node; j++) {\n      t_weights(i, j) = weights(i, j);\n    }\n  }\n\n  Eigen::MatrixXi t_eor(eor_nr, 2);\n  for (int i=0; i<eor_nr; i++) {\n    for (int j=0; j <2; j++) {\n      t_eor(i, j) = eor(i, j);\n    }\n  }\n\n  Eigen::VectorXi t_nlevels(node);\n  for (int i=0; i<node; i++) {\n    t_nlevels(i) = nlevels(i);\n  }\n\n  // Run CDAlgorithm\n\n CDAlgo(node, dataSize, t_data, t_nlevels, obsIndex, levelIndex, eor_nr, t_eor,\n        fmlam, nlam, eps, convLb, qtol, lambdaSeq, log_like, dur, betaM, betaN,\n        estimateG, t_weights, gamma, upperbound);\n\n  IntegerMatrix outputG(node*nlam, node);\n  for (int i=0; i<(node*nlam); i++) {\n    for (int j=0; j<node; j++) {\n      outputG(i, j) = estimateG(i, j);\n    }\n  }\n  // should return lambdaSeq, time.\n  // return estimateG;\n  return List::create(_[\"estimateG\"] = wrap(estimateG), _[\"lambdas\"] = wrap(lambdaSeq));\n}\n\n",
    "created" : 1460518890547.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3417360936",
    "id" : "EFEE75F5",
    "lastKnownWriteTime" : 1460590936,
    "path" : "~/Documents/STAT-COURSE/qualify/discretecdAlgorithm/discretecdAlgorithm/src/wrap.cpp",
    "project_path" : "src/wrap.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}